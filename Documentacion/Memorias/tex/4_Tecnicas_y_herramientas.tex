\capitulo{4}{Técnicas y herramientas}

\section{Introducción}
En esta sección vamos a hablar de las distintas técnicas y herramientas que hemos usado y analizado, mostrando las razones que nos han influenciado en tomar la decisión de usarlo.
Dada la gran cantidad de herramientas y técnicas para resolver los subproblemas de nuestra aplicación, hemos ido escogiendo varias de las herramientas disponibles y hemos cogido lo que mejor se ajustaba a nosotros.

En algunos casos las decisiones han estado muy claras, pero en otros no, así que a veces nos hemos decantado por lo conocido, y otras por lo que más sencillo era.

%\maketitle
\section{Gestores de tareas:}
\subsection{Trello}
Es una pizarra virtual también conocida como canvas en la cual podemos organizar nuestros proyectos a través de su aplicación web de forma fácil e intuitiva desde cualquier equipo en el que introduzcamos nuestra cuenta, ya que al estar en la nube no se pierde nuestra información ni aunque se degrade el sistema.

Podemos acceder a él a través del siguiente enlace: 
\url{https://trello.com/}



\textbf{Ventajas:}

\begin{itemize}
\item Es muy rápido su aprendizaje y su uso así, como su simplicidad.

\item La hemos usado en el transcurso de la carrera por lo que ya estamos familiarizados con el entorno.
\end{itemize}

\textbf{Desventajas:}

\begin{itemize}
\item No esta integrado dentro de nuestro repositorio por lo que lo tendríamos que usar como una herramienta más en la que al final duplicaríamos trabajo.
\end{itemize}


\subsection{Version One}
Es un gestor de tareas online en el cual podemos gestionar todas las tareas de nuestros proyectos, así como realizar un seguimiento de forma visual del estado del proyecto y de las características del mismo.

Podemos acceder a él a través del siguiente enlace: 
\url{https://www.versionone.com/}


\textbf{Ventajas:}

\begin{itemize}
\item Podemos incluir código, por lo que es más completo que otras herramientas de gestión de tareas.
\item incluye diversos gráficos que muestran el avance del proyecto de forma visual.
\item Está pensado y muy recomendado para metodologías ágiles.
\item Facilita la clasificación de tareas, bugs y otros tipos de eventos de metodologías ágiles a la perfección.
\end{itemize}

\textbf{Desventajas:}

\begin{itemize}
\item Como antes hemos indicado en este caso también sería algo que nos duplicaría trabajo al no estar integrado en nuestro repositorio. Sería también una herramienta a parte, que no se comunicaría con nuestro repositorio.
\end{itemize}


\subsection{ZenHub}
Es una herramienta similar a Trello que también es a modo de pizarra donde ver los cambios y el estado de un vistazo, pero con algunas diferencias.

Podemos Acceder a el a través del siguiente enlace: 
\url{https://www.zenhub.com/}



\textbf{Ventajas:}

\begin{itemize}
\item La ventaja principal es que podemos integrarlo desde GitHub por lo que ya no sería necesario duplicar trabajo con el uso de una aplicación externa.

\item Por este motivo he decidido usar esta herramienta.

\end{itemize}

\textbf{Desventajas:}

\begin{itemize}
\item No podremos añadir código pero tampoco es algo catastrófico, ya que justo en el repositorio donde se integra la herramienta podemos visualizar dicho código.

\end{itemize}

\section{Gestores de versiones:}
\subsection{GitHub}
Es un repositorio de versiones donde el código queda organizado por tareas (issues y ramas); las versiones, cada vez que hacemos un commit se actualizan las clases de código mostrando lo que ha cambiado.
El software esta escrito en Ruby, usando el framework Ruby on Rails.

Podemos Acceder a él a través del siguiente enlace: 
\url{https://github.com/}



\textbf{Ventajas:}

\begin{itemize}
\item Es de los repositorios mas usados y está basado en Git.

\item El código es público y cualquiera que le interese te puede proponer cambios en el mismo, seguirte y ver el proyecto.

\item Las distintas versiones del código están en la nube por lo que si se nos borra el contenido del disco duro aun así podremos recuperarlo.
\end{itemize}

\textbf{Desventajas:}

\begin{itemize}
\item También puedes tener proyectos privados solo con el modo de pago pero al no influir sobre este proyecto no pasa nada.
\end{itemize}


\subsection{Bitbucket}
Este repositorio web también guarda nuestro código y nuestras iteraciones sobre el proyecto para así tener una visión más completa sobre nuestro trabajo.
Este software está escrito en Python.

Podemos acceder a el a través del siguiente enlace: 
\url{https://bitbucket.org/}


\textbf{Ventajas:}
\begin{itemize}

\item Es un repositorio muy usado y que esta basado en Git que es casi la referencia en este tipo de proyectos.

\item Tiene cuentas gratuitas para proyectos privados y públicos.

\end{itemize}

\textbf{Desventajas:}

\begin{itemize}
\item No se puede incluir más de cinco personas en los proyectos gratuitos.
\end{itemize}

Nos hemos decidido por el repositorio GitHub porque es uno de los más usados y como se basa en Git, al igual que muchos de sus competidores, guarda mucha similitud con ellos.
Al utilizar dicho repositorio de forma apropiada no deberíamos tener problemas si el día de mañana queremos usar otro.


\section{Interfaz gráfica de usuario}
\subsection{Tkinter}
Es una librería que proporciona el diseño y visualización de interfaces de usuario en Python. Esta a su vez, esta basada en librerías de TK/TCL que están incluidas por en la propia instalación.

\subsubsection{Ventajas:}
\begin{itemize}
\item Es fácil de usar y es recomendable para el aprendizaje del lenguaje.

\item Viene preinstalado con la distribución anaconda, por lo que su uso es inmediato

\item Al servir para aprendices y venir preinstalado, podemos encontrar multitud de tutoriales y de documentación sobre ello.
\end{itemize}

\subsubsection{Desventajas:}
\begin{itemize}
\item Pocos elementos gráficos.
\item Escaso control de las ventanas.
\item Bastante lento en ejecución.
\end{itemize}

\subsection{WxPython}
Es una librería basada en otra importante que veremos más adelante, también es multiplataforma y esta programada en C/C++, es mas nueva que Tkinter.
\subsubsection{Ventajas:}
\begin{itemize}
\item Es más difícil de usar que Tkinter pero aun así hay mucha documentación sobre ella.

\item Dispone de gran cantidad de elementos gráficos por lo que es bastante potente aunque con alguna limitación respecto a otras.

\item Permite hacer una barrera o separación entre el código Python y lo que es la interfaz.
\item Cuenta con una gran comunidad de gente que lo usa y publica ejemplos y tutoriales.
\end{itemize}

\subsubsection{Desventajas:}
\begin{itemize}
\item La principal desventaja es que se actualizan las versiones mucho y para mantener una aplicación durante largo tiempo perdemos tiempo de.
\item Es más complejo de usar que el anterior.
\end{itemize}

\subsection{PyQt}
Es más difícil de usar que WxPython y WxWidget pero da más control sobre los elementos gráficos y muchas librerías se basan en ello, por lo que se puede encontrar bastante información sobre esta librería.


\subsubsection{Ventajas:}

\begin{itemize}
\item Al ser tan usada, si instalamos Python desde Anaconda, que es un cojunto de librerías y aplicaciones de Python, ya tendríamos PyQt4 por defecto instalado.

\item Podemos usar un IDE con el que estamos muy familiarizados en la carrera y que funciona muy bien (Eclipse) pero tenemos que instalar un plugin para Python (PyDev), ya que es un IDE basado en java, por lo que también debemos instalar Java 8.
\end{itemize}

\subsubsection{Desventajas:}

\begin{itemize}
\item Es más difícil de entender y comprender que los anteriores pero quedan más limpias las interfaces.
\item Si somos puristas e instalamos Python solo, sin IDE, no vendría instalado, pero si usamos Anaconda si que vendría instalado.
\end{itemize}

\subsection{WxWidgets:}
Como hemos mencionado anteriormente, es muy parecido a WxPython por lo que no vamos a entrar en detalle. También está programado en C/C++ y es multiplataforma, por lo que da un aspecto de comportamiento nativo.



\section{Plantillas}
Las plantillas sirven para generar código con la sustitución de los valores dentro de sus variables y así tener siempre un código con los valores en la ejecución.

Nosotros las vamos a usar en combinación con \LaTeX para generar el PDF con el informe de las estadísticas de la ejecución del algoritmo que detecta las líneas.

Como podemos observar hay muchos frameworks para usar las plantillas pero hemos elegido comparar varios usados otros años por compañeros.
\subsection{Mustache}
Pystache es una implementación de Mustache en Python para el diseño de plantillas y está inspirado en Ctemplate \cite{GitHub:CTemplate} y et \cite{et}.
En estos tipos de lenguaje no se puede aplicar lógica de aplicación simplemente son para una presentación más fluida.

\subsubsection{Ventajas:}

\begin{itemize}
\item Tiene documentación online.
\item Está disponible para una gran variedad de lenguajes de programación.
\item Si necesitásemos hacer documentos XML seria la herramienta perfecta.
\end{itemize}

\subsubsection{Desventajas:}
\begin{itemize}
\item Carece de ejemplos o tutoriales de cómo usarlo con \LaTeX{} en su versión de Python.
\end{itemize}


\subsection{Jinja2}

El nombre de la librería lo toma del templo Japonés Jinja .Sirve para escribir  plantillas en Python y funciona con las últimas versiones de este programa.Una de las librerías más usadas está inspirada en Django. 


\subsubsection{Ventajas:}
\begin{itemize}
\item Viene preinstalado con Anaconda ya que es uno de los más utilizados.
\item Fácil de usar y de pasar los parámetros.
\item Fue creada para Python2 pero también funciona en Python3.\end{itemize}

\subsubsection{Desventajas:}
\begin{itemize}
\item No esta implementado más que para Python.
\end{itemize}

\subsection{Comparación de las herramientas}
Esta comparación son dos filas, como se observa en la Tabla \ref{tb:1} sacada de la tabla comparativa de herramientas obtenida en Wikipedia \cite{Template:table}.


\begin{table}[]
\centering
\caption{Tabla comparativa de herramientas}
\label{tb:1}
\resizebox{\textwidth}{!}{
\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|l|l|}
\hline
Biblioteca & Lenguaje & Licencia & Variables & Funciones & Include & \begin{tabular}[c]{@{}l@{}}Inclusiones\\ condicionales\end{tabular} & Bucles & Evaluacion & Asignaciones &\begin{tabular}[c]{@{}l@{}} Errores y\\ excepciones\end{tabular} & \begin{tabular}[c]{@{}l@{}}Plantillas\\ naturales\end{tabular} & Herencia \\ \hline
Jinja2     & Python   & BSD      & SI        & SI        & SI      & SI                                                                  & SI     & SI         & SI           & SI                    & SI                                                             & SI       \\ \hline
Mustache   & +30      & MIT      & SI        & SI        & SI      & SI                                                                  & SI     & NO         & NO           & SI                    & SI                                                             & NO       \\ \hline
\end{tabular}
}
\end{table}
\section{IDE}
Un IDE es una aplicación para poder desarrollar código y ejecutarlo. Facilita la navegabilidad por los paquetes y puedes hacer ejecuciones controladas del código con puntos de rotura, donde mostrar los valores temporales de las variables.
En el argot de la informática estas herramientas son conocidas como <<debugers>>, son muy eficaces ,porque es más sencillo corregir los fallos . 

Es una herramienta que facilita mucho el trabajo para el desarrollo del software.Se compone, normalmente, de un editor de código fuente y un depurador. La mayoría del IDE tiene también autocompletado, compilador, indentador de código e intérprete.

\subsubsection{Ventajas:}
\begin{itemize}
	\item Maximizar la productividad.
	\item Unificar todo el ciclo de desarrollo en una herramienta.
	\item Algunos soportan múltiples lenguajes. 
	\item Sin ello es difícil leer código y editarlo.
\end{itemize}

\subsection{Eclipse:}
Es una aplicación software con muchos plugins y herramientas para el desarrollo de software, está basado en Java para su ejecución e instalación y para ello es necesario tener Java instalado.

Fue desarrollado por IBM en un principio, pero ahora esta desarrollado por la Fundación Eclipse, una fundación independiente y sin animo de lucro.


Podemos acceder a la pagina atraves del siguiente enlace  \url{https://eclipse.org/home/index.php}

\subsubsection{Ventajas:}
\begin{itemize}
	\item Lo hemos usado en múltiples asignaturas durante la carrera.
	\item Es gratuito por lo que podemos descargarlo sin problemas.
	\item Es un programa sencillo y completo.
\end{itemize}

\subsection{PyDev:}
Es un plugin para poder usar el IDE de Eclipse y sirve para programar en Python, Jython e IronPython. Se instala en Eclipse desde Help>Install New Software. 

Podemos encontrarlo a a través del siguiente enlace \url{http://www.pydev.org/}

\section{Modelado}
El modelado es la creación de diagramas qué nos explican que apariencia y comunicación van a tener los objetos entre ellos dentro de nuestra aplicación.

Hay muchas herramientas de este tipo en el mercado, pero en las asignaturas de la carrera hemos usado Astah, con la que ya estamos familiarizados. 


\subsection{Astah}
Es una herramienta de modelado UML para la creación de diagramas orientados a objetos.
Podríamos hacerlos dibujando pero es más preciso y profesional usar una herramienta  que está pensado para ello.
Podemos encontrar la herramienta a través del siguiente enlace  
\url{http://astah.net/}.

\section{XML}
Para guardar los nombres de los ficheros que se generan al guardar un proyecto, vamos a usar un archivo XML \cite{Wiki:xml}, que contenga los nombres de los ficheros que se generan.

XML significa Extensible Marking Language. Una de sus propiedades es la sencillez del lenguaje, y estructura el contenido por medio de los siguientes elementos: 
\begin{itemize}
\item Cuerpo: Es obligatorio en su sintaxis y normalmente contiene un elemento raíz del que cuelgan todos los demás.
\item Elementos: Pueden tener mas elementos, cadenas de caracteres o nada.
\item Atributos: Son las características o propiedades de los elementos. 
\item Secciones CDATA: Sirven para especificar caracteres especiales sin que rompan la estructura XML. 
\end{itemize}
 

En nuestro caso lo vamos a usar como un fichero donde se guardan todo lo que contendría un proyecto.
\subsection{Conclusión}
Después de analizar dos opciones de herramientas y viendo que todas ellas tienen gran similitud, vamos a usar la que ya conocemos como funciona, que nos va a servir para todos los diagramas.

\section{OCR}
Para entrar en materia adecuadamente para explicar la librería usada mas adelante vamos a introducir lo que es un OCR  \cite{OCR} y en que consiste.

Para definir  mejor la librería más usada vamos a introducir un OCR \cite{OCR}, y  explicar en qué consiste. 

Un OCR es un proceso dirigido a buscar de forma óptica un reconocimiento de caracteres en imágenes, es decir, hacer una extracción de características de la imagen en cuestión, devolviendo el texto que contiene la imagen.

\textbf{Ventajas:}
\begin{itemize}
\item Poder pasar documentos manuscritos a archivos de texto al ordenador.
\item Facilitar el trabajo que antes se hacía manualmente, de manera más rápida al realizarlo mediante un ordenador.
\item Poder automatizar muchos sistemas.
\end{itemize}

\textbf{Desventajas:}
\begin{itemize}
\item Dependiendo de qué dispositivo tome la imagen puede ocasionar ruidos, complicando o inutilizando el posterior reconocimiento.
\item La distancia desigual entre los caracteres puede variar en el reconocimiento produciendo errores. 
\item Se pueden producir incidencias que hagan peligrar  el funcionamiento.
\end{itemize}

\textbf{Pasos del algoritmo:}
\begin{itemize}
\item Binarizar la imagen.
\item Fragmentación y/o segmentación.
\item Skeletonizar los componentes.
\item Clasificar lo detectado.
\end{itemize}

\subsection{Tesseract}
Como podemos ver Tesseract~\cite{wiki:Tesseract} es un OCR de software libre.

Originalmente estaba hecho en C pero se migró a C++ en 1998. Más tarde fue concebido como Open Source en el 2005 al retomar el proyecto la universidad de Nevada (Las Vegas) en EEUU. Finalmente en 2006 fue retomado por Google.

La ventaja de esta librería es que se adapta a tus necesidades al reconocer varios idiomas o nuevos estilos de letras; según lo que se precise en cada situación. 

\section{Logger}
Es una herramienta que crea un fichero de registro, que almacena los mensajes de error que aparecen en la aplicación, facilitando el mantenimiento de esta.

Es una herramienta muy útil, ya que controlar todas las posibles excepciones es muy complicado y porque no sabemos por donde podría romper el código, de esta forma sabemos dónde ha roto o que lo ha causado.

\subsection{Logging}
Es la implementacion de un logger para Python \cite{python:logger} en este logger como en casi todos, podemos clasificar los mensajes de error en función de su gravedad en distintos niveles.

\begin{itemize}
\item Info: Para mensajes importante de información.
\item Warning: Para niveles que son avisos de que no se ha hecho lo que se quería pero no son graves.
\item Error: Para errores que han provocado un mal funcionamiento del programa.
\item Critical: Para mensajes que son críticos en nuestro programa.
\end{itemize}

\section{Ejecutable}
Se han detectado  dificultades a la hora de crear un .exe con las herramientas disponibles, debido a incompatibilidades de versiones, tanto las antiguas como las modernas, por lo que el problema se ha resuelto de otra forma.

\subsection{Py2exe}
Esta herramienta \cite{p2exe}, es una extensión que se encarga de empaquetar un script de Python en un ejecutable .exe, para poder distribuir la aplicación de forma que solo necesitemos el .exe para ejecutar todo, sin necesidad de tener Python instalado.

No la hemos podido usar ya que su última actualización es para Python 2.7.

\subsection{Py2app}
Esta herramienta es casi idéntica a la anterior pero solo esta disponible para MAC OS.

No la hemos podido usar ya que el cliente no va a usar MAC OS.

\subsection{Pyinstaller}
Esta herramienta \cite{Pyinstaller} si que hemos podido ser capaces de usarla, pero su última version esta disponible para Python 3.4.

A pesar  de estar indicado para Python 3.5, en la práctica no es asi. Ejecutándolo salían errores que se encontraron en las issues de su repositorio de GitHub, siguiendo las instrucciones de algunos usuarios era posible corregir algunos, pero no todos; por lo que el programa no ha dado resultado. 
Consultados algunos foros hemos podido saber que con 3.5. da problemas imposibles de solucionar. Quizás si se actualizase se pudieran corregir . 

Porque según lo investigado y visto en todo tipo de foros, llegamos a la conclusión que con 3.5 no le funciona a nadie.
No obstante en su siguiente actualización puede que lo corrijan y funcione para 3.5.

\subsection{cxFreeze}
Esta herramienta, es muy parecida a la de Py2exe, pero su última versión sigue estando únicamente estable para Python 3.4. 
Si buscamos mas en su repositorio vemos que menciona una version 3.5, pero no funciona ya que directamente no lo instala. Investigando se ha podido ver que a mucha gente le ha sido imposible trabajar con él. 

\subsection{Conclusión}
El problema anteriormente mencionado se podría haber corregido si hubiésemos hecho la aplicación en Python 2.7, pero cabe suponer que en el futuro las librerías no estén soportadas para esta versión, por dicha razón no lo hemos realizado en Python 2.7.
Hacerlo en Python 3.5, supone que no todas las herramientas son completamente compatibles para la generación del ejecutable.

Estimamos que este es un problema que se resolverá solo con la nueva versión de PyInstaller.
\section{Jupyter Notebook}
\label{notebook:jupiter}

Esta herramienta simula un editor y sin necesidad de programar interfaces, podemos ver gráficas e imágenes con los resultados obtenidos, por esto nos ha resultado mu útil.

Viene por defecto instalado en la distribución de anaconda y para ejecutarlo simplemente debemos escribir en una terminal, Jupyter Notebook, y nos lanzará una ventana en el explorador, donde cargar el fichero ipynb que contendrá el código del notebook guardando los datos de ejecuciones pasadas.


Para mas información podemos acceder a la pagina desde este enlace \url{http://jupyter.org/}

\section{SonarQube}
Esta herramienta, conocida antes como Sonar la podemos encontrar a traves de este enlace \url{https://www.sonarqube.org/}, esta destinada a evaluar código fuente, escrito en mas de 20 lenguajes, gracias a ella podemos obtener métricas que evalúan la calidad y ayudan a mejorarla.

Aspectos que evalúa SonarQube:
\begin{itemize}
	\item Complejidad: La complejidad es evaluada por esta herramienta midiendo los cambios de flujo que sufre el código, es decir cuando entran en condiciones de salto if, while, for, cases, catch, throw y return. Todo método como mínimo va a tener una complejidad de 1 ya que la propia llamada también aumenta en 1.
	\item Líneas de código: Es otro estadístico que nos muestra cuantas líneas hemos escrito en cada fichero de nuestra aplicación.
	\item Estructura: En este apartado nos muestra la estructura del programa como número de clases, directorios, ficheros, funciones, líneas y declaraciones de código.
	\item Technical Debt: Esta sección quizá es las más importante de la herramienta ya que te indica aspectos o métricas que no habíamos tenido en cuenta desde el principio, y otros que muestran la claridad del código.
	En lo referente a este apartado comentar que lo hemos encontrado de gran utilidad: Ya que te indica donde has cometido la falta de estilo o dónde has añadido demasiado complejidad. 
Si has roto algún estándar de los aplicables a tu lenguaje, también suma débito.
	\item Otros: En esta herramienta podemos añadir Plugins o componentes extra para customizar o evaluar otros aspectos mas del código.
\end{itemize}