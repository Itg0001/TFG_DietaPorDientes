\apendice{Planificación}

\section{Introducción}
Para la realización de este proyecto hemos seguido la metodología Scrum, la cual consiste en, tener una estrategia de desarrollo incremental del producto, semanalmente, juntar varias fases en paralelo del proyecto en vez del modo contrario que seria en cascada o secuencial. Por lo que, hemos usado la metodologia Scrum \cite{Scrum}, así en cada iteracion  vamos dando valor añadido al proyecto, siempre tenemos versiones nuevas y nuestro proyecto va teniendo mas valor.

Desde GitHub seguimos estos pasos cada semana:
\begin{itemize}
\item Creamos una Milestone con duración de una semana.
\item Creamos la issue o tarea correspondiente a la reunión semanal de una hora.
\item Vamos creando issues correspondientes a las demás tareas aquellas que son parecidas se incluyen en la misma tarea que se subdivide en puntos.
\item Respecto a la gestión temporal se realiza desde ZenHub, que es una herramienta incluida en el navegador e integrada en GitHub, las tareas se pasan de nuevas a abiertas
\item A medida que vamos finalizando las tareas las vamos incluyendo en cerradas, para poder ver el gráfico o burdownchar que nos indica el progreso perfecto frente al progreso real.

\end{itemize}


\section{Planificación temporal}
En esta sección vamos a entrar en detalle de lo que se ha hablado tanto en los sprint meetings <<reuniones semanales de sprint>> como de lo que se ha conseguido al terminar cada iteración. También vamos a observar en las gráficas como ha ido desarrollándose el trabajo en la linea temporal.

\subsection{Sprint 0 (9/9/2016 - 16/9/2016)}
Se ha especificado a grandes rasgos en que consiste el problema a resolver y unas recomendaciones, por parte de los tutores, para enfrentarnos a dicho problema.

Se va a hacer un mini prototipo para evaluar las herramientas, librerías y algoritmos necesarios. Posteriormente a la reunión con el cliente (Rebeca García \cite{Rebeca:garcia})\footnote{ Dra. Rebeca García González \cite{ubu:Rebe},  que estudia paleobiología y paleoecología de homínidos en la Universidad de Burgos} se decidirá el lenguaje y librerías a utilizar.

En esta primera iteración se ha hablado de evaluar las distintas herramientas de gestión, documentación y de programación y las tareas son:


\begin{itemize}
	\item Probar \LaTeX 
	\item Probar gestores de tarea: 
	\begin{itemize}
	\item Trello 
	\item Zenhub 
	\item Version One
	\end{itemize}
	\item Gestores de versiones 
	\begin{itemize}
	\item GitHub 
	\item Bitbucket 
	\end{itemize}
	\item Examinar el problema, evaluar el notebook y las posibilidades de las librerías 
	\item Echar un vistazo al artículo 
\end{itemize}

\subsubsection{Cumplido:}
Esta semana como aun no sabía muy bien cómo usar el repositorio  la gráfica no nos dice nada, porque tuvimos que cambiar el uso de los milestones.

El milestone inicial, ya que no era posible con GitHub usarlo como deseábamos, hasta la semana 1 no pondré burndown porque no refleja nada del trabajo hecho.

Todos los puntos han sido realizados y destacar, la implementación para el algoritmo ha sido amena, y ha funcionado aunque aun tiene cosas que otras semanas mejoraremos.

\subsection{Sprint 1 (16/9/2016 - 22/9/2016)}
 En esta semana vamos a tener tareas de interfaz gráfica , de documentación y de codificación y las tareas son:

\begin{itemize}
\item Mejora de la detección de las líneas que quedas solapadas. 
\item Analizar herramientas de interfaces gráficas y comparativa.
	\begin{itemize}
	\item PyQt4. 
	\item WxWidget.
	\end{itemize}
\item Prototipado inicial de la herramienta y documentar el prototipo.
\end{itemize}



\subsubsection{Cumplido:}
Esta semana hemos hecho algunos de los puntos mas relevantes del proyecto ya que la interfaz ha sido realizada correctamente con uso de layouts para facilitar el re-escalado de las pantallas sin que se oculten o descoloquen botones.

hemos ampliado el rango de frameworks de interfaces con Tkinter y WxPython porque al investigar vimos que también eran muy relevantes en este campo.

En cuanto a la mejora de la detección de líneas también mejoramos el algoritmo ajustando los parámetros y cambiando algunas propiedades.

También al aveces fallar y como aun no sabemos si es posible dejar pasar el fallo hemos implementado por recomendación de los tutores un modo manual para encontrar las líneas que no encontraba el algoritmo, a su vez también valdrá para pintar una imagen vacía manualmente.

En la figura~\ref{fig:A.2.1} se muestra el gráfico del Sprint 1.
\begin{figure}[h]
\centering
\includegraphics[width=0.99\textwidth]{Semana1}
\caption{Burndown del sprint 1}
\label{fig:A.2.1}
\end{figure}

\subsection{Sprint 2 (22/9/2016 - 30/9/2016)}
En la semana dos vamos a abarcar puntos de la interfaz y puntos de la documentación del proyecto y las tareas son:
 
\begin{itemize}
\item Documentación. 
\begin{itemize}
	\item Aspectos relevantes. 
	\item Técnicas y herramientas.
	\item Planificación temporal.
	\end{itemize}
\item Listas en la interfaz gráfica (Usar tablas para mostrar las rectas que hemos añadido manualmente).
\item Cargar imágenes con el file chooser.
\end{itemize}

\subsubsection{Cumplido:}
Hemos finalizado los objetivos aunque mas adelante y después de una revisión seguramente tengamos que modificar algunas cosas, añadir mas documentación ya que es la primera semana de documentación del proyecto.

Respecto al punto de la tabla donde aparezcan las listas de líneas que vamos añadiendo queda preguntar, si vendría bien añadir tres botones mas al modo manual.

Cosa que en la reunión con el Cliente (Rebeca Garcia \cite{Rebeca:garcia})\footnote{ Dra. Rebeca García González \cite{ubu:Rebe},  que estudia paleobiología y paleoecología de homínidos en la Universidad de Burgos} voy a exponer y posteriormente si parece bien desarrollar.

En cuanto al punto de cargar las imágenes con un \textit{file chooser} de paso, como me sobró algo de tiempo añadí una pantalla de inicio con un mensaje, así la primera vez que abramos la herramienta no se muestren tablas vacías ni una imagen predefinida.

Opte por hacer usar una pagina de inicio a modo de fachada y cuando se cargue la imagen ya iniciar todas las funcionalidades de la aplicación.
En la figura~\ref{fig:A.2.2} se muestra el gráfico del Sprint 2.
\begin{figure}[h]
\centering
\includegraphics[width=0.99\textwidth]{Semana2}
\caption{Burndown del sprint 2}
\label{fig:A.2.2}
\end{figure}

\subsection{Sprint 3 (30/9/2016 - 7/10/2016)}
En la semana tres vamos a abarcar puntos de la interfaz GUI , generar el informe, y pasar actualizar  el código de PyQt4 a PyQt5 y las tareas son:

\begin{itemize}
	\item Acabar la GUI.
		\begin{itemize}
			\item Mostrar todas las líneas en la tabla.
			\item Poder borrar la línea seleccionada.
		\end{itemize} 
	\item Informe.
		\begin{itemize}
			\item Calcular estadísticas.
			\item Mirar documentación Python.
		\end{itemize}
	\item Pasar código de PyQt4 a PyQt5.
\end{itemize}
\subsubsection{Cumplido:}
Hemos finalizado los objetivos de esta semana y hemos generado funcionalidad a la tabla para agregar las líneas, también añadido que se ilumine la línea seleccionada dentro de la imagen en color amarillo. Hemos añadido funcionalidad para borrar la línea que tenemos seleccionada y también para poder limpiar la tabla completa.

Respecto a la tarea del informe, hemos calculado los estadísticos de todas las líneas, también su clasificación y escritura dentro de un fichero CSV, también la generación de una tabla \LaTeX que se actualiza a cada ejecución con los datos que han salido para poder pegarla fácilmente a un informe.

Como nos dimos cuenta que la versión de PyQt se había actualizado de la cuatro a la cinco pues hemos pasado el código a la nueva version y no ha sido muy difícil.

En la figura~\ref{fig:A.2.3} se muestra el gráfico del Sprint 3.

\begin{figure}[h]
\centering
\includegraphics[width=0.99\textwidth]{Semana3}
\caption{Burndown del sprint 3}
\label{fig:A.2.3}
\end{figure}


\subsection{Sprint 4 (7/10/2016 - 14/10/2016)}
En esta semana vamos a abarcar el diseño software de la aplicación así como sacarlo de los NoteBooks y pasarlo a un IDE en condiciones con su subdivisión en clases y paquetes y las tareas son:
\begin{itemize}
	\item Diseño de la aplicación.
		\begin{itemize}
			\item Diagrama de clases.
			\item Diagrama de paquetes.
		\end{itemize}
		
	\item Implementación del código.
		
	\item Corrección de las memorias.
	
	\item Herramienta SonarQube.
	\begin{itemize}
		\item Ejecutar la aplicación.
		\item Corregir las horas de débito.
	\end{itemize}
\end{itemize}
\subsubsection{Cumplido:}
Hemos finalizado los objetivos del sprint.
En paralelo hemos implementado el diseño y el código a medida que teníamos una parte del diseño, de forma incremental, por lo que no se queda del todo reflejado cuando cerramos las tareas.

Hemos elegido Eclipse como IDE junto con su plugin PyDev para Python.

La división en clases hemos conseguido tener una primera estimación de como estaba la aplicación.
Respecto a la herramienta SonarQube hemos corregido todos los errores y defectos que salían, a mencionar que no había código repetido ni errores graves.

También detectamos un Bug y fue corregido:
Al mostrar las imágenes, tenia un fallo, consistía en que la imagen estaba como si viéramos su reflejo en un espejo, porque el eje de las <<$y$>> debe ir inverso a como lo conocemos, en vez de <<$0-tam-Image$>> debía ir de <<$tam-Imagen-0$>>.

En la figura~\ref{fig:A.2.4} se muestra el gráfico del Sprint 4.

\begin{figure}[h]
\centering
\includegraphics[width=0.99\textwidth]{Semana4}
\caption{Burndown del sprint 4}
\label{fig:A.2.4}
\end{figure}

\subsection{Sprint 5 (13/10/2016 - 22/10/2016)}
Esta semana vamos a continuar con el diseño de la aplicación aplicar los patrones correspondientes y paquetes de las clases.

\begin{itemize}
	\item Aplicar patrones de diseño
	\begin{itemize}
		\item Fachada.
		\item Mediador.
		\item Comando.
	\end{itemize}
	\item Documentar sobre los patrones usados.
	\item XML mirar documentación sobre ello.
\end{itemize}
\subsubsection{Cumplido:}
Esta semana, hemos finalizado los objetivos, hemos documentado los patrones y decidido que con el mediador ya nos servia y el fachada como entrada a la aplicación.
 
El patrón comando en Python no le hemos visto mucho sentido ya que en Python el connect con la función se hace en una sola linea por lo que no hace falta utilizar un patrón comando.

Respecto al XML hemos mirado documentación y lo hemos implementado que guarde los nombres de todos los archivos que generan un proyecto.

En la figura~\ref{fig:A.2.5} se muestra el gráfico del Sprint 5.

\begin{figure}[h]
\centering
\includegraphics[width=0.99\textwidth]{Semana5}
\caption{Burndown del sprint 5}
\label{fig:A.2.5}
\end{figure}
\subsection{Sprint 6 (22/10/2016 - 28/10/2016)}
Esta semana vamos a intentar ir terminando las tareas para poder la semana que viene tener un prototipo entregable de la aplicación.

\begin{itemize}
\item Completar menús de la GUI.
	\begin{itemize}
		\item Guardar.
		\item Cargar.
		\item Acerca de.
		\item Ayuda.
	\end{itemize}
\item Completar documentación de los fuentes.
	\begin{itemize}
		\item Paquete código.
		\item Paquete gui.
	\end{itemize}
\item Pruebas unitarias.
	\begin{itemize}
		\item Test paquete código.
		\item Test paquete gui.
	\end{itemize}
\end{itemize}
\subsubsection{Cumplido:}
Esta semana, hemos finalizado los objetivos, aunque en el gráfico no queda reflejado por el ataque del día 21 de octubre de 2016 \cite{wiki:Dyn} no pude cerrar las tareas del anterior sprint ni crear las de este.
Respecto a los menús de la gui, hemos añadido y renombrado los campos.

Las funcionalidades añadidas son:
Poder guardar los cambios, podamos abrir y modificar un proyecto, el acerca de y el botón sobre el que va a colgar la ayuda.
También hemos documentado los métodos de las clases del código fuente Python para poder generar la documentación automática con PyDoc.

También hemos desarrollado las pruebas unitarias de la aplicación de todas aquellas funciones que se podía comprobar. 


En la figura~\ref{fig:A.2.6} se muestra el gráfico del Sprint 6.

\begin{figure}[h]
\centering
\includegraphics[width=0.99\textwidth]{Semana6}
\caption{Burndown del sprint 6}
\label{fig:A.2.6}
\end{figure}

\subsection{Sprint 7 (28/10/2016 - 04/11/2016)}

Esta semana vamos a añadir funcionalidades para que el usuario tenga mas comodidad al usar la aplicación, evitando que pueda cometer errores o falsos positivos.


\begin{itemize}
	\item Detectar y calcular la referencia.
		\begin{itemize}
			\item Detectar la referencia.
			\item Calcular cuanto es la referencia.
		\end{itemize}
	\item Detectar la región pintable.
	\item Revisar toda la aplicación.
		\begin{itemize}
			\item Revisar el código con SonarQube.
			\item Ajustar los cálculos en algunos puntos.
			\item Añadir botón de cerrar.
		\end{itemize}
	\item Corregir la documentación.
		\begin{itemize}
			\item Memorias.
			\item Anexos.
		\end{itemize}			
\end{itemize}
\subsubsection{Cumplido:}
Esta semana, hemos finalizado todos los objetivos que nos habíamos propuesto, también hemos documentado bastante, no solo corregir lo que teníamos planteado.

El gráfico de esta semana se ha quedado muy desplazado hacia la derecha, porque hemos echo unas pruebas en ZenHub y al sacar varias tareas que ya estaban en cerradas, se ha despintado de la gráfica, pero todas ellas fueron terminadas en tiempo.

Las funcionalidades añadidas son:
\begin{itemize}
	\item Detectar la región pintable: Era uno de los puntos que nos faltaban, para poder conseguir que solo se pudieran pintar, a mano, las lineas dentro del cuadrado pintado por el usuario, en las imágenes. Porque solo esta permitido para este estudio las lineas que se encuentran dentro del recuadro en la imagen.
	\item Detectar y calcular la referencia: En las imágenes de microscopio, se les hace una marca con los aumentos con los que se han echo las imágenes, la referencia, que marca la escala y otros datos importantes.
	Nuestro trabajo ha sido detectarlo y calcular cuantos píxeles son.
	
	\item Hemos añadido el botón de cerrar la aplicación que era un punto en el que aun no habíamos pensado y es necesario.
	
	\item La mejora de la calidad del software pasando la herramienta SonarQube para corregir las posibles mejoras que nos proponga dicha herramienta. 
\end{itemize}

En la figura~\ref{fig:A.2.7} se muestra el gráfico del Sprint 7.

\begin{figure}[h]
\centering
\includegraphics[width=0.99\textwidth]{Semana7}
\caption{Burndown del sprint 7}
\label{fig:A.2.7}
\end{figure}

\subsection{Sprint 8 (04/11/2016 - 11/11/2016)}
Esta semana, va a consistir en investigar sobre el modo automático, dar valor al código en cuanto a calidad aplicando algún concepto de patrones de diseño, haciendo una fachada para la entrada salida.

\begin{itemize}
	\item Diseño:
		\begin{itemize}
			\item Desacoplar del mediador lo que debe ir en la fachada.
			\item Comprobar que los mediadores solo interfieren con aspectos de la GUI.
		\end{itemize}	
	\item Añadir Configuraciones al cálculo.
		\begin{itemize}
			\item Añadir las repeticiones.
			\item Añadir la longitud mínima para filtrar rectas.
		\end{itemize}
		\item Investigación detección de bordes por procesado
			\begin{itemize}
				\item Vamos a usar todos los algoritmos y métodos disponibles en las librerías.
				\item Programar otros conocidos pero que no existan en la librería.
				\item Buscar mucha mas información sobre los metodos conocidos para detección de bordes.
			\end{itemize}					
		\item Investigación detección de bordes por Deep Learning \cite{wiki:deep} \footnote{Conjunto de algoritmos de aprendizaje que modela abstracciones en datos, usando transformaciones no lineales}.
			\begin{itemize}
				\item StructuredForest.
				\item Retina-Unet. 
			\end{itemize}
\end{itemize}
\subsubsection{Cumplido:}
En esta semana, hemos finalizado los objetivos, además de buscar información sobre los métodos hemos creado un notebook con las pruebas de las ejecuciones de todos ellos.

La semana pasada implementamos la configuración, pero estaba en el código, no podía el usuario cambiarlo en función de sus necesidades.
Por lo que hemos extraído esa parte a la interfaz gráfica, así puede modificar los valores de configuración, guardarse en el XML, para cuando se cargue el proyecto, también se carguen esos valores.

En la figura~\ref{fig:A.2.8} se muestra el gráfico del Sprint 8.

\begin{figure}[h]
\centering
\includegraphics[width=0.99\textwidth]{Semana8}
\caption{Burndown del sprint 8}
\label{fig:A.2.8}
\end{figure}

\subsection{Sprint 9 (04/11/2016 - 11/11/2016)}

Esta semana, vamos a centrarnos en ejecutar y probar todos los métodos estudiados en la semana anterior, algunas modificaciones para facilitar al usuario, su simplicidad y mejorar, los posibles escenarios de ejecución.


\begin{itemize}
	\item Extracción de características.
		\begin{itemize}
			\item Aplicar Hough con valores ajustados.
			\item Extraer y procesar los segmentos.
		\end{itemize}
	\item Investigar y probar Deep Learning para Python 2.7.
		\begin{itemize}
			\item Probar en Python 2.7 ya que en 3.5 no funcionan los algoritmos.
		\end{itemize}
	\item Ejecutable sin dependencias.
		\begin{itemize}
			\item Crear un .exe pero no ha sido posible ya que no hay versiones actuales de esas herramientas para Python 3.5
			\item Crear una alternativa.
		\end{itemize}
	\item Documentar.
		\begin{itemize}
			\item Documentar Memorias. 
			\item Documentar Anexos.
		\end{itemize}
	\item Independencia del color.
		\begin{itemize}
			\item Modificar la distancia al color para que funcione con todos los colores.
		\end{itemize}
\end{itemize}

\subsubsection{Cumplido:}
Esta semana hemos finalizado los objetivos, pero no todo ha sido posible su implementación o realización.
Los algoritmos de Deep Learning, no hemos sido capaces de ejecutarlos, ya que están bastante desactualizados y las dependencias, no están demasiado claras, su ejecución no ha sido posible.

Todos los demás puntos del sprint, han sido realizados con éxito.
La parte de la independencia del color, nos ha permitido que ahora nuestra aplicación, funcione para todas las líneas indiferentemente, del color en el que estén pintadas, el usuario elije que color tienen y las busca.

Respecto a la extracción de características, del modo automático por procesado, hemos conseguido que sea decente partiendo de que las lineas no son fácilmente detectables y las que están mas marcadas no son las que nos interesan.

Para el ejecutable sin dependencias las opciones de crear el .exe no han sido posibles dada la desactualización de las herramientas destinadas a estos fines.
Como alternativa hemos creado una distribución de Miniconda especifica para nuestro propósito que solo contendrá las librerías necesarias para ello.

En la figura~\ref{fig:A.2.9} se muestra el gráfico del Sprint 9.

\begin{figure}[h]
\centering
\includegraphics[width=0.99\textwidth]{Semana9}
\caption{Burndown del sprint 9}
\label{fig:A.2.9}
\end{figure}


\subsection{Sprint 10 (18/11/2016 - 25/11/2016)}
Esta semana las tareas en las que nos vamos a centrar consistirán en investigar sobre aprendizaje automático, repasar el funcionamiento de la aplicación y permitir seleccionar el área a evaluar.

\begin{itemize}
	\item Añadir una forma de pintar el milímetro cuadrado que sera la región pintarle.
	\item Investigar mas sobre los algoritmos de deep learning.
	\item Repasar código para ver si esta correcto todo después de las ultimas modificaciones.
	\item Documentar y corregir las memorias.
\end{itemize}

\subsubsection{Cumplido:}
Hemos implementado con éxito, la selección del área a evaluar que se corresponde con 0,56 milímetros cuadrados, hemos repasado el código y retirado lineas comentadas, que ya no se usaban y hemos documentado y corregido las memorias y anexos.
La parte de Deep Learning no hemos sido capaces de ejecutar ninguno de los los proyectos que habíamos encontrado.

En la figura~\ref{fig:A.2.10} se muestra el gráfico del Sprint 10.

\begin{figure}[h]
\centering
\includegraphics[width=0.99\textwidth]{Semana10}
\caption{Burndown del sprint 10}
\label{fig:A.2.10}
\end{figure}

\subsection{Sprint 11 (25/11/2016 - 02/12/2016)}
Esta semana las tareas que vamos a realizar consistirán en, crear una ayuda para el usuario al usar la aplicación, investigación, acoplar la parte automática a la aplicación y documentar.
\begin{itemize}
	\item Documentar.
	\item Investigar Deep Learning.
	\item Crear la ayuda.
	\item Acoplar la parte de automático a la aplicación.
\end{itemize}

\subsubsection{Cumplido:}
Esta semana hemos finalizado con éxito los objetivos, acoplando la parte automática a nuestra aplicación de escritorio y la ayuda de usuario ha sido creada, también hemos documentado los aspectos que hemos utilizado, pero la parte de Deep Learning ha vuelto a quedarse sin poder ejecutar al no funcionar las nuevas herramientas de esta semana.

En la figura~\ref{fig:A.2.11} se muestra el gráfico del Sprint 11.

\begin{figure}[h]
\centering
\includegraphics[width=0.99\textwidth]{Semana11}
\caption{Burndown del sprint 11}
\label{fig:A.2.11}
\end{figure}


\subsection{Sprint 12 (02/12/2016 - 09/12/2016)}
Esta semana hemos cambiado la dirección de la investigación y las pruebas sobre algoritmos de Deep Learning al no haber tenido éxito probando los existentes en Python, hemos probado algoritmos en Matlab y hemos documentado las memorias y anexos.

\begin{itemize}
	\item Probar algoritmos de Matlab
	\item Documentar.
	\item Documentar parte dos.
\end{itemize}

\subsubsection{Cumplido:}
Esta semana hemos finalizado los objetivos aunque los resultados de la parte de Deep Learning no han sido demasiado buenos, ya que en la ejecución de los proyectos propuestos faltaban clases y no funcionaban dichas aplicaciones.
En la parte de documentación hemos avanzado bastante y hemos ido completando aspectos de las memorias y anexos.
En la figura~\ref{fig:A.2.12} se muestra el gráfico del Sprint 12.

\begin{figure}[h]
\centering
\includegraphics[width=0.99\textwidth]{Semana12}
\caption{Burndown del sprint 12}
\label{fig:A.2.12}
\end{figure}

\subsection{Sprint 13 (09/12/2016 - 16/12/2016)}
Esta semana vamos a crear un test de calidad para saber si nuestras predicciones de las estrias son buenas o no, y poder medir posteriormente como de bueno es otra forma de detectarlo.
Tambien vamos a documentar anexos y memorias de neustro proyecto y vamso a probar otro algoritmo de Deep Learning propuesto por el tutor.

\begin{itemize}
\item Crear una medida de calidad de nuestra aplicación.
\item Documentar anexos y memorias de nuestro proyecto.
\item Probar algoritmo propuesto por el tutor.
\end{itemize}
\subsubsection{Cumplido:}
Esta semana hemos finalizado el objetivo de crear la medida de calidad para las imágenes detectadas, como prototipo, también hemos realizado la documentación de anexos y memorias de las partes que habíamos planteado, hemos probado el algoritmo pero tampoco hemos sido capaces de hacerlo funcionar.


En la figura~\ref{fig:A.2.13} se muestra el gráfico del Sprint 13.

\begin{figure}[h]
\centering
\includegraphics[width=0.99\textwidth]{Semana13}
\caption{Burndown del sprint 13}
\label{fig:A.2.13}
\end{figure}

\subsection{Sprint 14 (16/12/2016 - 23/12/2016)}
Esta semana hemos planteado que ya casi tenemos todo terminado y que la medida de calidad debería ser especificada como un test dentro del programa por lo que hemos creado un test especifico para dicha medida, y la documentación vamos a ir revisando los puntos mas importantes y completándolos.

\begin{itemize}
	\item Documentar.
	\item Implementar test de calidad como test unitario.
\end{itemize}
\subsubsection{Cumplido:}
Esta semana hemos finalizado los objetivos marcados sin ningun contratiempo y sin imprevistos tangibles.

En la figura~\ref{fig:A.2.14} se muestra el gráfico del Sprint 14.

\begin{figure}[h]
\centering
\includegraphics[width=0.99\textwidth]{Semana14}
\caption{Burndown del sprint 14}
\label{fig:A.2.14}
\end{figure}

\subsection{Sprint 15 (23/12/2016 - 30/12/2016)}

\section{Estudio de viabilidad}
En esta sección vamos a realizar un estudio de viabilidad económica y otro de viabilidad legal, ya que son los dos aspectos mas relevantes vista a llevar a cabo el proyecto.
\subsection{Viabilidad económica}
En este punto, vamos a hacer es un estudio de viabilidad económica del proyecto. Vamos a analizar los gastos que hubiera supuesto, si fuese un proyecto real, para una empresa, en cuanto a tiempo de programación e infraestructura necesaria para ello.
\subsubsection{Costes de personal}
En este proyecto el personal ha estado compuesto por un programador que ha estado durante 4 meses y medio trabajando en sacar adelante el proyecto.
Como las horas han sido detalladas en la herramienta ZenHub podemos estimar que a día de hoy el proyecto consta de 480 Horas a 10\euro{} la hora:

\[10{\euro{}} /Hora*480Horas=4800{\euro{}} \]

Por otro lado tambien vamos a incluir las horas de reuniones semanales con nuestro equipo de proyecto, los tutores, este aspecto serian 16 horas extra en reuniones y otras 10 horas aproximadamente en consultas con ellos.
\[10{\euro{}} /Hora*26Horas=260{\euro{}} \]

A esta cuantía debemos añadirle el valor que se debería llevar la Seguridad Social que equivaldría a:
\begin{itemize}
\item 23,6\%: Por Seguridad Social.
\item 5,5\%: Por desempleo.
\item 0,6\%: Por formación profesional.
\item 0,2\%: Por Fogasa.
\item Total: 29,9\% 
\end{itemize}
Y esto equivale a: 
\[5060\euro{}*0.299=1513\euro{}\]
\subsubsection{Costes de material}
Por software no tenemos costes algunos ya que todos lo que usamos no necesita licencias de pago.
Por el hardware yo he usado mi propio equipo que tiene un valor de 1065\euro{} se considera que la amortización de un equipo ronda los 5 años y nosotros lo hemos usado 4 meses y medio por lo tanto el coste en hardware ha sido: 
\[\frac{1065\euro{}}{(12Meses*5Periodos)}*4.5MesesDeUso=79.9\euro{}\]
\subsubsection{Costes totales}
Como costes totales sumaremos todos los anteriores, como se puede observar en la tabla \ref{tab:costes}.

\begin{table}[]
\centering
\caption{Tabla de los costes totales}
\label{tab:costes}
\resizebox{0.5\textwidth}{!}{
\begin{tabular}{@{} ll @{}}
\toprule
Costes de personal         & 5060 \euro{}   \\ \midrule
Costes de seguridad social & 1513\euro{} \\ \midrule
Costes de material         & 79.9\euro{}   \\ \midrule
Costes totales             & 6713\euro{} \\ \bottomrule
\end{tabular}
}
\end{table}

\subsection{Viabilidad legal}
En este punto lo que vamos a hacer es analizar las librerías que hemos usado en nuestro proyecto. Buscar los tipos de licencias que tienen cada uno, luego analizar, dependiendo de las compatibilidades, que tipos de licencia podemos aplicar nuestro proyecto y seleccionar uno de ellos.

\begin{table}[]
	\centering
	\caption{Tabla de librerías y sus licencias}
	\label{tabla:Licencias}
	\begin{tabular}{@{}l l l l@{}}
	\toprule
	Librería     & Versión & Descripción                                                     & Licencia                \\ 	\midrule
	Jinja2       & 2.8     &  \begin{tabular}[c]{@{}l@{}}Un motor de plantillas escrito\\ en Python. \end{tabular}               & BSD                     \\ 	
	Numpy        & 1.11.1  & \begin{tabular}[c]{@{}l@{}}Procesamiento de arrays para\\ números,strings,records y objetos.\end{tabular} & BSD                     \\ 	
	Scipy        & 0.18.1  & Librería científica para Python.                                & BSD                     \\ 	
	Scikit-image & 0.12.3  & \begin{tabular}[c]{@{}l@{}}Librería para tratamiento\\ de imágenes para SciPy.\end{tabular}	               & BSD                     \\ 	
	Networkx     & 1.11    & \begin{tabular}[c]{@{}l@{}}Librería Python para crear y\\ analizar redes complejas.\end{tabular}          & BSD                     \\ 	
	Pillow       & 3.3.1   & \begin{tabular}[c]{@{}l@{}}Librería Python para\\ tratamiento de imágenes.\end{tabular} & \begin{tabular}[c]{@{}l@{}}PIL license\\ similar MIT\end{tabular} \\ 
	Pyqt         & 5.6.0   & Librería Python para crear GUI.                                 &\begin{tabular}[c]{@{}l@{}} GPLv2 o\\ GPLv3\end{tabular}           \\ 
	Matplotlib   & 1.5.3   & \begin{tabular}[c]{@{}l@{}}Librería Python para mostrar\\ gráficos 2D.\end{tabular}                      & PSF-based               \\ 
	Tesseract    & 3.02    & Ocr para ejecutar en Windows.                                   & Apachev2                \\ \bottomrule
\end{tabular}
\end{table}


BSD de tres clausulas es compatible con GPL, pero la licencia mas restrictiva es la GPL, por lo que nuestro software deberá llevar dicha licencia.
